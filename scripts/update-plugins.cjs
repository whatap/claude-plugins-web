#!/usr/bin/env node

/**
 * update-plugins.js
 *
 * repository_dispatch 이벤트로 받은 플러그인 데이터를
 * src/data/plugins.ts 파일로 변환
 */

const fs = require('fs');
const path = require('path');

const PLUGINS_FILE = path.join(__dirname, '..', 'src', 'data', 'plugins.ts');

function escapeString(str) {
  if (!str) return '';
  return str
    .replace(/\\/g, '\\\\')
    .replace(/`/g, '\\`')
    .replace(/\$/g, '\\$');
}

function generatePluginsTs(plugins) {
  const pluginEntries = plugins.map(plugin => {
    const readmeContent = plugin.readme ? escapeString(plugin.readme) : '';

    return `  {
    name: '${plugin.name}',
    version: '${plugin.version}',
    description: '${escapeString(plugin.description)}',
    category: '${plugin.category}',
    keywords: ${JSON.stringify(plugin.keywords)},
    author: ${plugin.author ? `{
      name: '${escapeString(plugin.author.name)}',
      email: '${plugin.author.email || ''}',
    }` : 'undefined'},
    homepage: '${plugin.homepage || ''}',
    repository: '${plugin.repository || ''}',
    license: '${plugin.license || 'MIT'}',
    platform: ${JSON.stringify(plugin.platform || [])},
    readme: \`${readmeContent}\`,
  }`;
  });

  return `import type { Plugin } from './types'

// Auto-generated by update-plugins.js
// Do not edit manually - changes will be overwritten

export const plugins: Plugin[] = [
${pluginEntries.join(',\n')}
]

export function getPluginByName(name: string): Plugin | undefined {
  return plugins.find((p) => p.name === name)
}

export function searchPlugins(query: string, category?: string, tags?: string[]): Plugin[] {
  return plugins.filter((plugin) => {
    // Search query
    if (query) {
      const q = query.toLowerCase()
      const matchesQuery =
        plugin.name.toLowerCase().includes(q) ||
        plugin.description.toLowerCase().includes(q) ||
        plugin.keywords.some((k) => k.toLowerCase().includes(q))
      if (!matchesQuery) return false
    }

    // Category filter
    if (category && category !== 'all' && plugin.category !== category) {
      return false
    }

    // Tags filter
    if (tags && tags.length > 0) {
      const hasTag = tags.some((tag) =>
        plugin.keywords.some((k) => k.toLowerCase() === tag.toLowerCase())
      )
      if (!hasTag) return false
    }

    return true
  })
}
`;
}

function main() {
  // PLUGINS_JSON 환경변수에서 플러그인 데이터 읽기
  const pluginsJson = process.env.PLUGINS_JSON;

  if (!pluginsJson) {
    console.error('Error: PLUGINS_JSON environment variable is required');
    process.exit(1);
  }

  let plugins;
  try {
    plugins = JSON.parse(pluginsJson);
  } catch (error) {
    console.error('Error parsing PLUGINS_JSON:', error.message);
    process.exit(1);
  }

  if (!Array.isArray(plugins)) {
    console.error('Error: PLUGINS_JSON must be an array');
    process.exit(1);
  }

  console.log(`Processing ${plugins.length} plugins...`);

  const content = generatePluginsTs(plugins);

  fs.writeFileSync(PLUGINS_FILE, content, 'utf-8');
  console.log(`Generated ${PLUGINS_FILE}`);

  // 플러그인 목록 출력
  plugins.forEach(p => {
    console.log(`  - ${p.name} v${p.version}`);
  });
}

main();
